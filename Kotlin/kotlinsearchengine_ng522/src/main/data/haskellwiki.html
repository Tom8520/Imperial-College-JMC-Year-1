
<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
    <meta charset="UTF-8"/>
    <title>Introduction - HaskellWiki</title>
    <script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
    <script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Introduction","wgTitle":"Introduction","wgCurRevisionId":63206,"wgRevisionId":63206,"wgArticleId":1314,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Tutorials","Language"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Introduction","wgRelevantArticleId":1314,"wgRequestId":"e6a8fde3977a930939db544a","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":false,"dialogs":false,"preview":false,"publish":false},"wgCollapsibleVectorEnabledModules":{"collapsiblenav":true,"experiments":true}});mw.loader.implement("user.options",function($,jQuery,require,module){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function ( $, jQuery, require, module ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});/*@nomin*/;

});mw.loader.load(["mediawiki.page.startup","skins.hawiki.js"]);});</script>
    <link rel="stylesheet" href="/load.php?debug=false&amp;lang=en&amp;modules=ext.pygments%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.hawiki.styles&amp;only=styles&amp;skin=hawiki"/>
    <meta name="ResourceLoaderDynamicStyles" content=""/>
    <link rel="stylesheet" href="/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=hawiki"/>
    <script async="" src="/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=hawiki"></script>
    <meta name="generator" content="MediaWiki 1.27.4"/>
    <link rel="shortcut icon" href="/wikistatic/favicon.ico"/>
    <link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="HaskellWiki (en)"/>
    <link rel="EditURI" type="application/rsd+xml" href="https://wiki.haskell.org/api.php?action=rsd"/>
    <link rel="copyright" href="/HaskellWiki:Copyrights"/>
    <link rel="alternate" type="application/atom+xml" title="HaskellWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom"/>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Introduction rootpage-Introduction skin-hawiki action-view">
<div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
    <a id="top"></a>

    <div class="mw-indicators">
    </div>
    <h1 id="firstHeading" class="firstHeading" lang="en">Introduction</h1>
    <div id="bodyContent" class="mw-body-content">
        <div id="siteSub">From HaskellWiki</div>
        <div id="contentSub"></div>
        <div id="jump-to-nav" class="mw-jump">
            Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
        </div>
        <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>Haskell is a computer programming language.  In particular, it is a
            <i> <a href="/Polymorphism" title="Polymorphism">polymorphically</a> <a href="/Typing" title="Typing">statically typed</a>, <a href="/Lazy_evaluation" title="Lazy evaluation">lazy</a>, <a href="/Functional_programming" title="Functional programming">purely functional</a> </i> language,
            quite different from most other programming languages.
            The language is named for <a href="/Haskell_Brooks_Curry" title="Haskell Brooks Curry">Haskell Brooks Curry</a>, whose work in mathematical logic serves as a foundation for
            functional languages.
            Haskell is based on the <i><a href="/Lambda_calculus" title="Lambda calculus">lambda calculus</a></i>, hence the lambda we use as a logo.
        </p><p><br />
        </p>
            <div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
                <ul>
                    <li class="toclevel-1 tocsection-1"><a href="#Why_use_Haskell.3F"><span class="tocnumber">1</span> <span class="toctext">Why use Haskell?</span></a></li>
                    <li class="toclevel-1 tocsection-2"><a href="#What_is_functional_programming.3F"><span class="tocnumber">2</span> <span class="toctext">What is functional programming?</span></a></li>
                    <li class="toclevel-1 tocsection-3"><a href="#What.27s_good_about_functional_programming.3F"><span class="tocnumber">3</span> <span class="toctext">What's good about functional programming?</span></a>
                        <ul>
                            <li class="toclevel-2 tocsection-4"><a href="#Quicksort_in_Haskell"><span class="tocnumber">3.1</span> <span class="toctext">Quicksort in Haskell</span></a></li>
                            <li class="toclevel-2 tocsection-5"><a href="#Quicksort_in_C"><span class="tocnumber">3.2</span> <span class="toctext">Quicksort in C</span></a></li>
                            <li class="toclevel-2 tocsection-6"><a href="#Ease_of_understanding"><span class="tocnumber">3.3</span> <span class="toctext">Ease of understanding</span></a></li>
                            <li class="toclevel-2 tocsection-7"><a href="#Brevity"><span class="tocnumber">3.4</span> <span class="toctext">Brevity</span></a></li>
                            <li class="toclevel-2 tocsection-8"><a href="#No_core_dumps"><span class="tocnumber">3.5</span> <span class="toctext">No core dumps</span></a></li>
                            <li class="toclevel-2 tocsection-9"><a href="#Code_re-use"><span class="tocnumber">3.6</span> <span class="toctext">Code re-use</span></a></li>
                            <li class="toclevel-2 tocsection-10"><a href="#Strong_glue"><span class="tocnumber">3.7</span> <span class="toctext">Strong glue</span></a></li>
                            <li class="toclevel-2 tocsection-11"><a href="#Powerful_abstractions"><span class="tocnumber">3.8</span> <span class="toctext">Powerful abstractions</span></a></li>
                            <li class="toclevel-2 tocsection-12"><a href="#Built-in_memory_management"><span class="tocnumber">3.9</span> <span class="toctext">Built-in memory management</span></a></li>
                        </ul>
                    </li>
                    <li class="toclevel-1 tocsection-13"><a href="#When_C_is_better"><span class="tocnumber">4</span> <span class="toctext">When C is better</span></a>
                        <ul>
                            <li class="toclevel-2 tocsection-14"><a href="#Functional_vs_imperative"><span class="tocnumber">4.1</span> <span class="toctext">Functional vs imperative</span></a></li>
                        </ul>
                    </li>
                    <li class="toclevel-1 tocsection-15"><a href="#What_is_Haskell.3F"><span class="tocnumber">5</span> <span class="toctext">What is Haskell?</span></a></li>
                    <li class="toclevel-1 tocsection-16"><a href="#Does_anyone_use_functional_programming.3F"><span class="tocnumber">6</span> <span class="toctext">Does anyone use functional programming?</span></a></li>
                    <li class="toclevel-1 tocsection-17"><a href="#Other_frequently-asked_questions"><span class="tocnumber">7</span> <span class="toctext">Other frequently-asked questions</span></a>
                        <ul>
                            <li class="toclevel-2 tocsection-18"><a href="#Is_functional_programming_hard_to_learn.3F"><span class="tocnumber">7.1</span> <span class="toctext"><i>Is functional programming hard to learn?</i></span></a></li>
                            <li class="toclevel-2 tocsection-19"><a href="#Aren.27t_functional_programs_very_slow.3F"><span class="tocnumber">7.2</span> <span class="toctext"><i>Aren't functional programs very slow?</i></span></a></li>
                            <li class="toclevel-2 tocsection-20"><a href="#I_already_have_a_large_application_in_C_or_C.2B.2B."><span class="tocnumber">7.3</span> <span class="toctext"><i>I already have a large application in C or C++.</i></span></a></li>
                            <li class="toclevel-2 tocsection-21"><a href="#What_libraries_does_Haskell_support.3F"><span class="tocnumber">7.4</span> <span class="toctext"><i> What libraries does Haskell support?</i></span></a></li>
                            <li class="toclevel-2 tocsection-22"><a href="#What_other_software_tools_for_Haskell_are_there.3F"><span class="tocnumber">7.5</span> <span class="toctext"><i> What other software tools for Haskell are there? </i></span></a></li>
                            <li class="toclevel-2 tocsection-23"><a href="#How_can_I_ask_for_help.3F"><span class="tocnumber">7.6</span> <span class="toctext"><i>How can I ask for help?</i></span></a></li>
                            <li class="toclevel-2 tocsection-24"><a href="#Can_I_get_a_support_contract_or_a_help-line.3F"><span class="tocnumber">7.7</span> <span class="toctext"><i>Can I get a support contract or a help-line?</i></span></a></li>
                            <li class="toclevel-2 tocsection-25"><a href="#How_can_I_learn_Haskell.3F"><span class="tocnumber">7.8</span> <span class="toctext"><i>How can I learn Haskell?</i></span></a></li>
                            <li class="toclevel-2 tocsection-26"><a href="#Comparisons_to_other_languages"><span class="tocnumber">7.9</span> <span class="toctext"><i>Comparisons to other languages</i></span></a></li>
                        </ul>
                    </li>
                </ul>
            </div>

            <h2><span class="mw-headline" id="Why_use_Haskell.3F">Why use Haskell?</span></h2>
            <p>Writing large software systems that
                work is difficult and expensive.  Maintaining those systems is even
                more difficult and expensive.  Functional programming languages, such
                as Haskell, can make it easier and cheaper.  For example, a new user who
                wrote a small relational DBMS in Haskell had this to say:
            </p>
            <blockquote>
                <p>WOW!  I basically wrote this without testing just thinking about my
                    program in terms of transformations between types.  I wrote the
                    test/example code and had almost no implementation errors in the code!  The
                    compiler/type-system is really really good at preventing you from
                    making coding mistakes!  I've never in my life had a block of code
                    this big work on the first try.  I am WAY impressed.
                </p>
            </blockquote>
            <p>Even if you are not in a position to use Haskell in your programming projects, learning Haskell can make you a better programmer in any language.
            </p>
            <blockquote>
                <p>I learned Haskell a couple of years ago, having previously programmed in
                    Python and (many) other languages.  Recently, I've been using Python for a
                    project (the choice being determined by both technical and non-technical
                    issues), and find my Python programming style is now heavily influenced (for the better, I hope&#160;;-) by my Haskell programming experience.<br /><br />
                    Graham Klyne
                </p>
            </blockquote>
            <p><br />
                Haskell offers you:
            </p>
            <ul><li>Substantially increased programmer productivity (Ericsson measured an improvement factor of between 9 and 25 using Erlang, a functional programming language similar to Haskell, in one set of experiments on telephony software).</li>
                <li>Shorter, clearer, and more maintainable code.</li>
                <li>Fewer errors, higher reliability.</li>
                <li>A smaller &quot;semantic gap&quot; between the programmer and the language.</li>
                <li>Shorter lead times.</li></ul>
            <p>Haskell is a wide-spectrum language, suitable for a variety of
                applications.  It is particularly suitable for programs which need to
                be highly modifiable and maintainable.
            </p><p>Much of a software product's life is spent in <i>specification</i>,
                <i>design</i> and <i>maintenance</i>, and not in <i>programming</i>.
                Functional languages are superb for writing specifications which can
                actually be executed (and hence tested and debugged).  Such a
                specification then <i>is</i> the first prototype of the final
                program.
            </p><p>Functional programs are also relatively easy to maintain, because the
                code is shorter, clearer, and the rigorous control of side effects
                eliminates a huge class of unforeseen interactions.
            </p>
            <h2><span class="mw-headline" id="What_is_functional_programming.3F">What is functional programming?</span></h2>
            <p>C, Java, Pascal, Ada, and so on, are all <i>imperative</i>
                languages.  They are &quot;imperative&quot; in the sense that they
                consist of a sequence of commands, which are executed strictly one
                after the other.  Haskell is a <i>functional</i> language.  A
                functional program is a single expression, which is executed by
                evaluating the expression.
            </p><p>Anyone who has used a spreadsheet has experience of functional
                programming.  In a spreadsheet, one specifies the value of each cell
                in terms of the values of other cells.  The focus is on <i>what</i> is
                to be computed, not <i>how</i> it should be computed.  For
                example:
            </p>
            <ul><li>we do not specify the order in which the cells should be calculated -&#160;instead we take it for granted that the spreadsheet will compute cells in an order which respects their dependencies.</li>
                <li>we do not tell the spreadsheet how to allocate its memory - rather, we expect it to present us with an apparently infinite plane of cells, and to allocate memory only to those cells which are actually in use.</li>
                <li>for the most part, we specify the value of a cell by an <i>expression</i> (whose parts can be evaluated in any order), rather than by a <i>sequence of commands </i> which computes its value.</li></ul>
            <p>An interesting consequence of the spreadsheet's unspecified order
                of re-calculation is that the notion of assignment is not very useful.
                After all, if you don't know exactly when an assignment will
                happen, you can't make much use of it!  This contrasts strongly
                with programs in conventional languages like C, which consist
                essentially of a carefully-specified sequence of assignments, or Java,
                in which the ordering of method calls is crucial to the meaning of a
                program.
            </p><p>This focus on the high-level &quot;what&quot; rather than the
                low-level &quot;how&quot; is a distinguishing characteristic of
                functional programming languages.
            </p><p>Another well-known nearly-functional language is the standard database
                query language SQL.  An SQL query is an expression involving
                projections, selections, joins and so forth.  The query says what
                relation should be computed, without saying how it should be computed.
                Indeed, the query can be evaluated in any convenient order. SQL
                implementations often perform extensive query optimization which
                (among other things) figures out the best order in which to evaluate
                the expression.
            </p>
            <h2><span class="mw-headline" id="What.27s_good_about_functional_programming.3F">What's good about functional programming?</span></h2>
            <p>Spreadsheets and SQL are both fairly specialized languages.  Functional
                programming languages take the same ideas and move them into the realm
                of general-purpose programming. To get an idea of what a functional
                program is like, and the expressiveness of functional languages, look at
                the following quicksort programs.  They both sort a sequence of numbers
                into ascending order using a standard method called "quicksort". The
                first program is written in Haskell and the second in C.
            </p><p>Whereas the C program describes the particular steps the machine must
                make to perform a sort -- with most code dealing with the low-level
                details of data manipulation -- the Haskell program encodes the sorting
                algorithm at a much higher level, with improved brevity and clarity as
                a result (at the cost of efficiency unless compiled by a very smart compiler):
            </p>
            <h3><span class="mw-headline" id="Quicksort_in_Haskell">Quicksort in Haskell</span></h3>
            <p>The first thing to know about Haskell's syntax is that parentheses are used for grouping, and not for function application.  The application of a function <span class="inline-code"><code class="mw-highlight" dir="ltr"><span class="nf">f</span></code></span> to an argument <span class="inline-code"><code class="mw-highlight" dir="ltr"><span class="nf">x</span></code></span> is written <span class="inline-code"><code class="mw-highlight" dir="ltr"><span class="nf">f</span> <span class="n">x</span></code></span>, not necessarily <span class="inline-code"><code class="mw-highlight" dir="ltr"><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></span>.  It can be written as <span class="inline-code"><code class="mw-highlight" dir="ltr"><span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span></code></span> to separate it from its surroundings.
            </p>
            <div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="nf">quicksort</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">quicksort</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">quicksort</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">lesser</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">greater</span><span class="p">)</span>
    <span class="kr">where</span>
        <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
        <span class="n">greater</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
            <p>The parentheses indicate the grouping of operands on the right-hand side of equations.  On the left they indicate <i>patterns</i> of a function's argument(s).  The parentheses around the two function calls <code>(quicksort lesser)</code> and <code>(quicksort greater)</code> are not necessary &#8211; because function application binds tighter than infix operators &#8211; and are there just for clarity.
            </p><p>Here <code>[]</code> stands for empty list, <code>[p]</code> for a singleton list holding one element <code>p</code>, <code>++</code> is a built-in list concatenation operator, and the two <code>filter</code> calls use two on-the-fly built predicates, first for getting all the elements of <code>xs</code> that are smaller than the pivot element <code>p</code>, and the other - all those greater than, or equal to it.
            </p><p>This definition uses Haskell's ability to define functions as equations with pattern-matching clauses: here the first one, with <code>[]</code> pattern for an empty list on its left-hand side, and the second, with <code>(p:xs)</code> pattern on its left-hand side standing for non-empty list with the head element <code>p</code> (used as a pivot element), and the tail <code>xs</code> (which is read, by convention, as <i>axes</i>, suggesting that it is a list of several <i>xs</i>, viz. elements <i>"x"</i>).
            </p><p>The very first line above is the function's <i>type signature</i>: it says that <code>quicksort</code> transforms a list of elements of some type <code>a</code> (usually read "alpha") into a list of the same type, for a type <code>a</code> that is an instance of typeclass <span class="inline-code"><code class="mw-highlight" dir="ltr"><span class="kt">Ord</span></code></span> (which means that comparison operations are defined for it, so elements of type <code>a</code> can be compared with one another).
            </p>
            <h3><span class="mw-headline" id="Quicksort_in_C">Quicksort in C</span></h3>
            <p>True quicksort in C sorts in-place:
            </p>
            <pre>
// To sort array a[] of size n: qsort(a,0,n-1)

void qsort(int a[], int lo, int hi)
{
  int h, l, p, t;

  if (lo &lt; hi) {
    l = lo;
    h = hi;
    p = a[hi];

    do {
      while ((l &lt; h) &amp;&amp; (a[l] &lt;= p))
          l = l+1;
      while ((h &gt; l) &amp;&amp; (a[h] &gt;= p))
          h = h-1;
      if (l &lt; h) {
          t = a[l];
          a[l] = a[h];
          a[h] = t;
      }
    } while (l &lt; h);

    a[hi] = a[l];
    a[l] = p;

    qsort( a, lo, l-1 );
    qsort( a, l+1, hi );
  }
}
</pre>
            <p>A <a href="/Introduction/Direct_Translation" title="Introduction/Direct Translation"> semi-direct translation</a> of the C code is here.
            </p><p>Let's examine some of the benefits of Haskell and functional programming.
                A more detailed case for functional programming can be found in
            </p>
            <blockquote>
                <p><a rel="nofollow" class="external text" href="http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf"><b>Why Functional Programming Matters</b></a> by <a rel="nofollow" class="external text" href="http://www.cse.chalmers.se/~rjmh/">John Hughes</a>, The Computer
                    Journal, Vol. 32, No. 2, 1989, pp. 98 - 107. Also in: David A. Turner
                    (ed.): Research Topics in Functional Programming, Addison-Wesley,
                    1990, pp. 17 - 42.
                </p>
            </blockquote>
            <p>A slightly less formal essay inspired by the paper above can be found in
            </p>
            <blockquote>
                <p><a href="/Why_Haskell_matters" title="Why Haskell matters"><b>Why Haskell Matters</b></a> originally by <a rel="nofollow" class="external text" href="mailto:sylvan@dtek.chalmers.se">Sebastian Sylvan</a>
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="Ease_of_understanding">Ease of understanding</span></h3>
            <p>Functional programs are often easier to <b>understand</b>: it is usually possible to get their meaning at a glance. The same certainly cannot be said of the C program.  It takes quite a while to understand, and even when you do understand it, it is extremely easy to make a small slip and end up with an incorrect program.
            </p><p>Here is a detailed explanation of the Haskell quicksort:
            </p>
            <div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="nf">quicksort</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
            <p>The first clause reads: "The result of sorting an empty list (<tt>[]</tt>) is just an empty list (<tt>[]</tt>)".
            </p>
            <div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="nf">quicksort</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">lesser</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">greater</span><span class="p">)</span>
    <span class="kr">where</span>
        <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
        <span class="n">greater</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
            <p>The second clause reads: "The result of sorting a non-empty list whose first element will be henceforth referred to as <tt>p</tt> and
                the rest of which will be referred to as <tt>xs</tt>, is a result of concatenating three sublists: first the result of sorting the elements of <tt>xs</tt> that are less than <tt>p</tt>, then <tt>p</tt> itself, and then the result of sorting the elements of <tt>xs</tt> that are greater than or equal to <tt>p</tt>."
            </p>
            <h3><span class="mw-headline" id="Brevity">Brevity</span></h3>
            <p>Functional programs tend to be much more <b>concise</b>, shorter by a factor of two to ten usually, than their imperative counterparts.
            </p><p>The above could be written even more concisely with the help of <a href="/List_comprehension" title="List comprehension">list comprehensions</a>:
            </p>
            <div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="nf">qsort</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">qsort</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span><span class="ow">&lt;-</span><span class="n">xs</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span><span class="ow">&lt;-</span><span class="n">xs</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">p</span><span class="p">]</span>
</pre></div>
            <p>The first sub-expression means, for <code>x</code> drawn from <code>xs</code> in order, such that <code>x &lt; p</code>, collect <code>x</code>s in a list and call the <code>qsort</code> function with it, recursively. Similarly for the last one.
            </p>
            <h3><span class="mw-headline" id="No_core_dumps">No core dumps</span></h3>
            <p>Most functional languages, and Haskell in particular, are <b>strongly</b>
                typed<b>, eliminating a huge class of easy-to-make errors at compile</b>
                time.   In particular, strong typing means <b>no core dumps</b>!
                There is simply no possibility of treating an integer as a pointer, or
                following a null pointer.
            </p>
            <h3><span class="mw-headline" id="Code_re-use">Code re-use</span></h3>
            <p>Of course, strong typing is available in many imperative languages, such as Ada or Pascal.  However, Haskell's type system is much less restrictive than, say, Pascal's, because it uses <b><a href="/Polymorphism" title="Polymorphism">polymorphism</a></b>.
            </p><p>For example, the qsort program given in Figure 1 will not only sort lists of integers, but also lists of floating point numbers, lists of characters, lists of lists; indeed, it will sort lists of <i>anything</i> for which it is meaningful to have "less-than" and "greater-than" operations. In contrast, the C version can only sort an array of integers, and nothing else.
            </p><p>Polymorphism enhances re-usability.
            </p>
            <h3><span class="mw-headline" id="Strong_glue">Strong glue</span></h3>
            <p>"Non-strict" functional languages, such as Haskell, have another powerful feature: they
                only evaluate as much of the program as is required to get the answer
                - this is called <a href="/Haskell/Lazy_evaluation" title="Haskell/Lazy evaluation"><b>lazy evaluation</b></a>.   This feature is rather
                like Unix pipes.  For example, the Unix command
            </p>
            <pre>
grep printf Foo.c | wc
</pre>
            <p>counts the number of lines in the file <tt> Foo.c </tt>that include the
                string <tt>printf</tt>.
                The command
            </p>
            <pre>
grep printf Foo.c
</pre>
            <p>produces all lines which contain the string &quot;<tt>printf</tt>&quot;,
                while the &quot;<tt>wc</tt>&quot; command counts them.  The pipe,
                written &quot;<tt>|</tt>&quot;, takes the output from the first command
                and delivers it to the second.  The two commands execute together, so
                that the output of the first is consumed more-or-less immediately by
                the second.  In this way, no large intermediate files need be
                produced.  You can think of <tt>wc</tt> &quot;demanding&quot;
                lines from the <tt>grep</tt>.
            </p><p>If the second command only needs some of the output of the first, then
                execution of the first command might never need to be completed.  For
                example,
            </p>
            <pre>
grep printf Foo.c | head 5
</pre>
            <p>just prints the first 5 lines which contain &quot;<tt>printf</tt>&quot;.
                There is no need to modify the <tt>grep</tt> command to take account of
                the fact that its execution might be abandoned.
            </p><p><a href="/Lazy_vs._non-strict" title="Lazy vs. non-strict">Non-strict</a> languages provide exactly this kind of demand-driven
                evaluation.  Data structures are evaluated just enough to deliver the
                answer, and parts of them may not be evaluated at all.  As in the case
                of Unix commands, this provides powerful &quot;glue&quot; with which
                to compose existing programs together.  What this means is that it is
                possible to <b>re-use programs</b>, or pieces of programs, much more
                often than can be done in an imperative setting.  <a href="/Haskell/Lazy_evaluation" title="Haskell/Lazy evaluation">Lazy evaluation</a> allows us to write more <b>modular programs</b>.
            </p>
            <h3><span class="mw-headline" id="Powerful_abstractions">Powerful abstractions</span></h3>
            <p>In general, functional languages offer powerful new ways to
                encapsulate <b>abstractions</b>.  An abstraction allows you to define
                an object whose internal workings are hidden; a C procedure, for
                example, is an abstraction.  Abstractions are <i>the</i> key to
                building modular, maintainable programs, so much so that a good
                question to ask of any new language is "what mechanisms for
                abstraction does it provide?".
            </p><p>One powerful abstraction mechanism available in functional languages
                is the <b><a href="/Higher_order_function" title="Higher order function">higher order function</a></b>.  In Haskell a function is a
                first-class citizen: it can freely be passed to other functions,
                returned as the result of a function, stored in a data structure, and
                so on.  It turns out that the judicious use of higher order functions
                can substantially improve the structure and modularity of many
                programs.
            </p>
            <h3><span class="mw-headline" id="Built-in_memory_management">Built-in memory management</span></h3>
            <p>Very many sophisticated programs need to allocate dynamic memory from a heap.  In C this is done with a call to <tt> malloc</tt>, followed by code to initialize the store just allocated.  The programmer is responsible for returning the store to the free pool when it isn't needed any more, a notorious source of "dangling-pointer" errors. To make matters worse, <tt>malloc</tt> is fairly expensive performance-wise, so programmers often <tt>malloc</tt> a  single large chunk of store, and then allocate "by hand" out of this.
            </p><p>Every functional language relieves the programmer of this storage management burden.  Store is allocated and initialized implicitly, and recovered automatically by the garbage collector.  The technology of storage allocation and garbage collection is now well developed, and the performance costs are rather slight.
            </p>
            <h2><span class="mw-headline" id="When_C_is_better">When C is better</span></h2>
            <p>It isn't all roses, of course.  The C quicksort uses an extremely
                ingenious technique, invented by Hoare, whereby it sorts the array
                <i>in place</i>; that is, without using any extra storage.  As a
                result, it runs quickly, and in a small amount of memory.  In
                contrast, the Haskell program allocates quite a lot of extra memory
                behind the scenes, and runs rather slower than the C program.
            </p><p>In effect, the C quicksort does some very ingenious storage
                management, trading this algorithmic complexity for a reduction in
                run-time storage management costs.
            </p><p>In applications where <a href="/Performance" title="Performance">performance</a> is required at any cost, or when the
                goal is detailed tuning of a low-level algorithm, an imperative
                language like C would probably be a better choice than Haskell,
                exactly because it provides more intimate control over the exact way
                in which the computation is carried out - that is, until sufficiently smart compiler appears that is able to derive the C equivalent from the Haskell one-liner, all by itself.
            </p>
            <h3><span class="mw-headline" id="Functional_vs_imperative">Functional vs imperative</span></h3>
            <p>But few programs require performance at any cost!   After all, we all
                stopped writing assembly-language programs, except perhaps for key
                inner loops, long ago.   The benefits of having a more supportive
                programming model (an arbitrary number of named, local variables
                instead of a fixed number of registers, for example) far outweigh the
                modest run-time costs.
            </p><p>Similarly, we willingly accept the costs of a virtual memory paging
                system, in exchange for the more supportive programming model of an
                infinite virtual address space.  The days of explicit memory overlays
                are over.
            </p><p>Functional languages take another large step towards a higher-level
                programming model.  Programs are easier to design, write and maintain,
                but the language offers the programmer less control over the machine.
                For most programs the result is perfectly acceptable.
            </p>
            <h2><span class="mw-headline" id="What_is_Haskell.3F">What is Haskell?</span></h2>
            <p>Haskell is a modern, standard, non-strict, purely-functional
                programming language.  It provides all the features sketched above,
                including polymorphic typing, lazy evaluation and higher-order
                functions.  It also has an innovative type system which supports a
                systematic form of overloading and a module system.
            </p><p>It is specifically designed to handle a wide range of applications,
                from numerical through to symbolic.  To this end, Haskell has an
                expressive syntax, and a rich variety of built-in data types,
                including arbitrary-precision integers and rationals, as well as the
                more conventional integer, floating-point and boolean types.
            </p><p>There are a number of <a href="/Implementations" title="Implementations">compilers and interpreters</a> available.  All are
                free.  The recommend way to install Haskell on your computer is through the the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/platform/">Haskell Platform</a>.
            </p><p>See also the <a href="/History_of_Haskell" title="History of Haskell">History of Haskell</a>.
            </p>
            <h2><span class="mw-headline" id="Does_anyone_use_functional_programming.3F">Does anyone use functional programming?</span></h2>
            <p>Functional programming languages are used in substantial applications.
                For example:
            </p>
            <ul><li> Software AG, a major German software company, market an expert system (Natural Expert) which is programmed in a functional language.  Their users find it easy to develop their applications in this language, through which they gain access to an underlying database system.  It all runs on an IBM mainframe.</li>
                <li>Ericsson have developed a new functional language, Erlang, to use in their future telephony applications.  They have already written 130k-line Erlang applications, and find them very much shorter and faster to develop.</li>
                <li>Amoco ran an experiment in which they re-coded in Miranda, a lazy functional language, a substantial fraction of their main oil-reservoir simulation code, a critical application.  The resulting program was vastly shorter, and its production revealed a number of errors in the existing software.  Amoco subsequently transcribed the functional program into C++ with encouraging results.</li>
                <li>A researcher at the MITRE corporation is using Haskell to prototype his digital signal-processing applications.</li>
                <li>Researchers at Durham University used Miranda, and later Haskell, in a seven-year project to build LOLITA, a 30,000-line program for natural-language understanding.</li>
                <li>Query is the query language of the O2 object-oriented database system. O2Query is probably the most sophisticated commercially-available object-oriented database query language  and it is a functional language.</li>
                <li>ICAD Inc market a CAD system for mechanical and aeronautical engineers.  The language in which the engineers describe their design is functional, and it uses lazy evaluation extensively to avoid recomputing parts of the design which are not currently visible on the screen.  This results in substantial performance improvements.</li>
                <li>An incestuous example: the Glasgow Haskell compiler is written in Haskell: a 100,000-line application.</li>
                <li><a rel="nofollow" class="external text" href="http://pugscode.org">Pugs</a>, which was the leading perl6 implementation, is written in Haskell</li>
                <li>As is <a rel="nofollow" class="external text" href="http://darcs.net">Darcs</a>, a cutting edge distributed revision control system</li></ul>
            <p>Some other examples of <a href="/Haskell_in_practice" title="Haskell in practice">Haskell in practice</a>.
            </p><p>Clifford Beshers, of <a rel="nofollow" class="external text" href="http://www.linspire.com/">Linspire Inc</a>., describes their experience with Haskell, and functional programming:
            </p>
            <blockquote>
                <p>Linspire, Inc. has used functional programming since its inception in
                    2001, beginning with extensive use of O'Caml, with a steady shift to
                    Haskell as its implementations and libraries have matured.  Hardware
                    detection, software packaging and CGI web page generation are all areas
                    where we have used functional programming extensively.
                </p>
            </blockquote>
            <blockquote>
                <p>Haskell's feature set lets us replace much of our use of little
                    languages (e.g., bash or awk) and two-level languages (C or C++ bound to
                    an interpreted language), allowing for faster development, better code
                    sharing and ultimately faster implementations. Above all, we value
                    static type checking for minimizing runtime errors in applications that
                    run in unknown environments and for wrapping legacy programs in strongly
                    typed functions to ensure that we pass valid arguments.
                </p>
            </blockquote>
            <h2><span class="mw-headline" id="Other_frequently-asked_questions">Other frequently-asked questions</span></h2>
            <p>There is also a <a href="/FAQ" title="FAQ">larger FAQ</a> in progress.
            </p>
            <h3><span class="mw-headline" id="Is_functional_programming_hard_to_learn.3F"><i>Is functional programming hard to learn?</i></span></h3>
            <blockquote>
                <p>Functional programming does require a change in perspective, which
                    some programmers find hard.  But Ericsson's experience in training
                    programmers in Erlang is that most find the transition easy -
                    provided they take the training need seriously rather than assuming
                    that they can "pick it up on the day".
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="Aren.27t_functional_programs_very_slow.3F"><i>Aren't functional programs very slow?</i></span></h3>
            <blockquote>They used to be, perhaps 20 years ago. But the compilers
                <p>have long since caught up. Haskell programs run fast for all but the
                    most performance-demanding applications. At the time of writing, Haskell
                    compiled via GHC is doing quite well in the
                    <a rel="nofollow" class="external text" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">The Computer Language Benchmarks Game</a>, with other functional languages also ranked highly.
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="I_already_have_a_large_application_in_C_or_C.2B.2B."><i>I already have a large application in C or C++.</i></span></h3>
            <p>Also worded as: <i>Can I benefit from functional programming without rewriting my whole system?</i>
            </p>
            <blockquote>
                <p>Haskell has been successfully integrated into existing applications in
                    a number of ways.
                    <a rel="nofollow" class="external text" href="http://web.archive.org/web/20100703013753/https://www.haskell.org/hdirect/">HaskellDirect</a> is
                    an IDL (Interface Description Language) based tool that allows Haskell
                    programs to work with software components.  Low level C/C++ interfaces
                    can be generated with
                    <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/greencard">Green Card</a> or
                    <a rel="nofollow" class="external text" href="http://web.archive.org/web/20180621211300/www.cse.unsw.edu.au/~chak/haskell/c2hs/">C-&gt;Haskell</a>, allowing
                    tight integration between Haskell and C.  These tools have been used
                    to build a large number of successful, mixed language systems.
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="What_libraries_does_Haskell_support.3F"><i> What libraries does Haskell support?</i></span></h3>
            <blockquote>
                <p>Many software libraries have been developed for Haskell.  See the
                    <a href="/Libraries_and_tools" title="Libraries and tools" class="mw-redirect"> list of Haskell libraries</a> for a list of much of
                    what is available.
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="What_other_software_tools_for_Haskell_are_there.3F"><i> What other software tools for Haskell are there? </i></span></h3>
            <blockquote>
                <p>Glasgow Haskell comes with a profiler which allows you to find which
                    parts of your program are consuming most time and space.  Chalmers
                    Haskell has a space-profiling tool, and a quasi-parallel simulator
                    which allows you to experiment with running your program in
                    parallel. Hugs also has some similar tools. For a complete list, check
                    the <a href="/Libraries_and_tools" title="Libraries and tools" class="mw-redirect">tools page</a>.
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="How_can_I_ask_for_help.3F"><i>How can I ask for help?</i></span></h3>
            <p>There is a large community of Haskell users willing to help. They can be contacted on mailing lists, IRC, or Stack Overflow.
            </p>
            <h3><span class="mw-headline" id="Can_I_get_a_support_contract_or_a_help-line.3F"><i>Can I get a support contract or a help-line?</i></span></h3>
            <blockquote>
                <p>It used to be the case that if you wanted help, you had to persuade a
                    Haskell research group that your problem was interesting enough or
                    important enough that they should spend time helping you for free.
                    <br />
                    Whilst that is still an option, there is now a
                    <a href="/Consultants" title="Consultants">directory of Haskell Consultants</a> who provide:
                </p>
                <ul><li>Support for compilers, tools and libraries.</li>
                    <li>Help with improving code quality (time, space, robustness,     maintainability, etc.) using code reviews and tools.</li>
                    <li>Help with using libraries, tools and advanced Haskell features such as type system extensions, exception handling, the foreign function interface, test harnesses, and concurrency.</li>
                    <li>Library and application development.</li>
                    <li>Staff training.</li></ul>
                <p>These companies and individuals tend to work closely with those
                    developing Haskell (indeed, they have usually made major
                    contributions to Haskell themselves).
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="How_can_I_learn_Haskell.3F"><i>How can I learn Haskell?</i></span></h3>
            <blockquote>
                <p>The easiest way to learn Haskell is with a <a href="/Books" title="Books">textbook</a>. There are a lot of <a href="/Tutorials" title="Tutorials">online tutorials</a>, but you'll have a much easier time to learn the basics from a book. After all, Haskell is very different from traditional mainstream languages, it's like learning programming anew.
                </p>
            </blockquote>
            <h3><span class="mw-headline" id="Comparisons_to_other_languages"><i>Comparisons to other languages</i></span></h3>
            <blockquote>
                <p><a href="/Comparison_of_functional_programming_languages" title="Comparison of functional programming languages"> Click to see a table comparing features of Haskell to similar languages</a>
                </p>
            </blockquote>
            <p><i>Based on a paper by Simon Peyton Jones.</i>
            </p>
            <!--
            NewPP limit report
            Cached time: 20201125030924
            Cache expiry: 86400
            Dynamic content: false
            CPU time usage: 0.036 seconds
            Real time usage: 0.038 seconds
            Preprocessor visited node count: 229/1000000
            Preprocessor generated node count: 388/1000000
            Post‐expand include size: 0/2097152 bytes
            Template argument size: 0/2097152 bytes
            Highest expansion depth: 2/40
            Expensive parser function count: 0/100
            -->

            <!--
            Transclusion expansion time report (%,ms,calls,template)
            100.00%    0.000      1 - -total
            -->

            <!-- Saved in parser cache with key wikidb_haskell:pcache:idhash:1314-0!*!0!!en!*!* and timestamp 20201125030924 and revision id 63206
             -->
        </div>					<div class="printfooter">
        Retrieved from "<a dir="ltr" href="https://wiki.haskell.org/index.php?title=Introduction&amp;oldid=63206">https://wiki.haskell.org/index.php?title=Introduction&amp;oldid=63206</a>"					</div>
        <div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/Category:Tutorials" title="Category:Tutorials">Tutorials</a></li><li><a href="/Category:Language" title="Category:Language">Language</a></li></ul></div></div>				<div class="visualClear"></div>
    </div>
</div>
<div id="mw-navigation">
    <h2>Navigation menu</h2>

    <div id="mw-head">
        <div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
            <h3 id="p-personal-label">Personal tools</h3>
            <ul>
                <li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=Introduction" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
        </div>
        <div id="left-navigation">
            <div id="p-namespaces" role="navigation" class="hawikiTabs" aria-labelledby="p-namespaces-label">
                <h3 id="p-namespaces-label">Namespaces</h3>
                <ul>
                    <li  id="ca-nstab-main" class="selected"><span><a href="/Introduction"  title="View the content page [c]" accesskey="c">Page</a></span></li>
                    <li  id="ca-talk"><span><a href="/Talk:Introduction"  title="Discussion about the content page [t]" accesskey="t" rel="discussion">Discussion</a></span></li>
                </ul>
            </div>
            <div id="p-variants" role="navigation" class="hawikiMenu emptyPortlet" aria-labelledby="p-variants-label">
                <h3 id="p-variants-label">
                    <span>Variants</span><a href="#"></a>
                </h3>

                <div class="menu">
                    <ul>
                    </ul>
                </div>
            </div>
        </div>
        <div id="right-navigation">
            <div id="p-views" role="navigation" class="hawikiTabs" aria-labelledby="p-views-label">
                <h3 id="p-views-label">Views</h3>
                <ul>
                    <li id="ca-view" class="selected"><span><a href="/Introduction" >Read</a></span></li>
                    <li id="ca-viewsource"><span><a href="/index.php?title=Introduction&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
                    <li id="ca-history" class="collapsible"><span><a href="/index.php?title=Introduction&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
                </ul>
            </div>
            <div id="p-cactions" role="navigation" class="hawikiMenu emptyPortlet" aria-labelledby="p-cactions-label">
                <h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

                <div class="menu">
                    <ul>
                    </ul>
                </div>
            </div>
            <div id="p-search" role="search">
                <h3>
                    <label for="searchInput">Search</label>
                </h3>

                <form action="/index.php" id="searchform">
                    <div id="simpleSearch">
                        <input type="search" name="search" placeholder="Search" title="Search HaskellWiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
                </form>
            </div>
        </div>
    </div>
    <div id="mw-panel">
        <div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/Haskell"  title="Visit the main page"></a></div>
        <div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
            <h3 id='p-navigation-label'>Navigation</h3>

            <div class="body">
                <ul>
                    <li id="n-mainpage"><a href="/Haskell" title="Visit the main page [z]" accesskey="z">Haskell</a></li><li id="n-portal"><a href="/HaskellWiki:Community" title="About the project, what you can do, where to find things">Wiki community</a></li><li id="n-recentchanges"><a href="/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>					</ul>
            </div>
        </div>
        <div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
            <h3 id='p-tb-label'>Tools</h3>

            <div class="body">
                <ul>
                    <li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/Introduction" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/Introduction" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="/index.php?title=Introduction&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="/index.php?title=Introduction&amp;oldid=63206" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="/index.php?title=Introduction&amp;action=info" title="More information about this page">Page information</a></li><li id="t-cite"><a href="/index.php?title=Special:CiteThisPage&amp;page=Introduction&amp;id=63206" title="Information on how to cite this page">Cite this page</a></li>					</ul>
            </div>
        </div>
    </div>
</div>
<div id="footer" role="contentinfo">
    <ul id="footer-info">
        <li id="footer-info-lastmod"> This page was last modified on 29 February 2020, at 23:54.</li>
        <li id="footer-info-copyright">Recent content is available under <a href="/HaskellWiki:Copyrights" title="HaskellWiki:Copyrights">simple permissive license</a>.</li>
    </ul>
    <ul id="footer-places">
        <li id="footer-places-privacy"><a href="/HaskellWiki:Privacy_policy" title="HaskellWiki:Privacy policy">Privacy policy</a></li>
        <li id="footer-places-about"><a href="/HaskellWiki:About" title="HaskellWiki:About">About HaskellWiki</a></li>
        <li id="footer-places-disclaimer"><a href="/HaskellWiki:General_disclaimer" title="HaskellWiki:General disclaimer">Disclaimers</a></li>
    </ul>
    <div style="clear:both"></div>
</div>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.loader.state({"user":"ready","user.groups":"ready"});mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","site","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"]);});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":49});});</script>
</body>
</html>
